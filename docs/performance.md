# ビルド環境

## リリースビルド
Rust コンパイラは、クレートを複数のcodegen ユニットに分割して、コンパイルを並列化 (したがって高速化) します。ただし、これにより、潜在的な最適化が失われる可能性があります。ユニット数を 1 に設定することで、コンパイル時間が長くなる代わりに、実行速度を向上させます。

```Rust
[profile.release]
codegen-units = 1
```

## リンク時の最適化
リンク時最適化(LTO) は、プログラム全体の最適化手法であり、コンパイル時間が長くなるという代償を払って、実行速度を 10 ～ 20% 以上向上させ、バイナリ サイズも削減することができます。Levelが上がるごとに効果が大きいです。デフォルトではLevel 1が暗黙的に設定されています。


```Rust
[profile.release]
lto = false // Level 1
lto = "thin" // Level 2
lto = "fat" // Level 3
```


## 代替アロケータ
Rust プログラムで使用されるデフォルト (システム) ヒープ アロケータを代替アロケータに置き換えることができます。正確な効果は個々のプログラムと選択された代替アロケータによって異なりますが、実行速度の大幅な向上とメモリ使用量の大幅な削減が実際に確認されています。各プラットフォームのシステム アロケータには独自の長所と短所があるため、効果はプラットフォーム間でも異なります。代替アロケータを使用すると、バイナリ サイズとコンパイル時間が増加する可能性もあります。

### ミマロック
Windowsを含む多くの環境で動作する代替アロケータの1つです。


```Rust
// Cargo.toml
[dependencies]
mimalloc = "0.1"

// codeの先頭に追記
#[global_allocator]
static GLOBAL: mimalloc::MiMalloc = mimalloc::MiMalloc;
```

# プロファイリング
プログラムを最適化する際には、プログラムのどの部分が「ホット」（実行時間に影響を与えるほど頻繁に実行される）で、変更する価値があるかを判断する方法も必要です。これはプロファイリングによって行うのが最適です。

Windows環境で動作する汎用プロファイラは以下の通りです。<br>

| プロファイラ | 概要 |
| ---- | ---- |
| [Intel VTune Profiler](https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html) | Intelプロセッサに最適化された汎用プロファイラ |
| [AMD μProf](https://developer.amd.com/amd-uprof/) | AMDプロセッサに最適化された汎用プロファイラ。電力プロファイリングも可能 |
| [DHAT](https://www.valgrind.org/docs/manual/dh-manual.html) | コードのどの部分が大量の割り当てを引き起こしているかを見つけ、ピーク時のメモリ使用量を把握可能 |


## ハッシュ
fxhashからデフォルトのHashMapに戻したことで[4~84%の速度低下](https://github.com/rust-lang/rust/issues/69153#issuecomment-589338446)が発祥した事例もあります

キーが整数など、ハッシュ計算を使用しなくてよい場合は[nohash-hasher](https://crates.io/crates/nohash-hasher)クレートが効果的です。このクレートはハッシュ計算を省略しています。

ハッシュ計算とは・・・<br>
データを固定長の値（ハッシュ値）に変換するプロセスのことです。ハッシュ関数を使用して行われ、データの検索と格納、整合性チェック、暗号化を目的としています。

ハッシュ系の速度比較などは[aHashクレート](https://github.com/tkaitchuck/aHash/blob/master/compare/readme.md)の説明の一部として書かれています。

# ヒープ割り当て

## String
std::format_argsのメリット
効率的なフォーマット: std::format_argsは、フォーマット文字列と引数を事前に解析し、効率的にフォーマットを行います。これにより、複数回のフォーマット操作が必要な場合でも、パフォーマンスが向上します1。
型安全性: std::format_argsは型安全なフォーマットを提供し、コンパイル時にエラーを検出することができます1。
柔軟性: フォーマット文字列と引数を分離して扱うことができるため、柔軟なフォーマット操作が可能です1。

lazy_formatクレートのメリット
遅延フォーマット: lazy_format!マクロは、引数をキャプチャして遅延評価を行います。これにより、実際のフォーマットが必要になるまでフォーマット操作を遅延させることができます2。
メモリ効率: 一時的な文字列を生成せずに、最終的な出力先バッファに直接フォーマットを行うため、メモリ効率が向上します2。
軽量: lazy_formatクレートはno_stdライブラリとして提供されており、組み込みシステムやリソースが限られた環境でも使用できます3。


## clone 
clone_fromは、既存のオブジェクトのメモリを再利用して新しいオブジェクトをコピーするため、不要なメモリ割り当てを避けることができます。これにより、メモリ使用量が削減され、パフォーマンスが向上します
```Rust
let mut v1: Vec<u32> = Vec::with_capacity(99);
let v2: Vec<u32> = vec![1, 2, 3];
v1.clone_from(&v2); // v1's allocation is reused
assert_eq!(v1.capacity(), 99);
```

## リグレッションを避ける
コードによって行われる割り当ての数やサイズが意図せず増加しないようにするには、[dhat-rs](https://crates.io/crates/dhat)の ヒープ使用量テスト機能を使用して、特定のコード スニペットが予想される量のヒープ メモリを割り当てているかどうかを確認するテストを記述できます。

## Rc::make_mutおよびArc::make_mutの利点
これらのメソッドは、参照カウントが1の場合に元の値を直接変更します。これにより、不要なメモリ割り当てを避けることができます1。
参照カウントが1より大きい場合には、内部の値をクローンして一意の所有権を確保します。これにより、他の参照が影響を受けることなく安全に値を変更できます。

```Rust
use std::rc::Rc;

let mut rc = Rc::new(5);
let rc_clone = Rc::clone(&rc);

// 参照カウントが2なので、内部の値をクローンして一意の所有権を確保
let rc_mut = Rc::make_mut(&mut rc);
*rc_mut += 1;

println!("rc: {}, rc_clone: {}", rc, rc_clone); // rc: 6, rc_clone: 5
```


## 並列処理
[rayon](https://crates.io/crates/rayon)クレートを使用すると、
イテレータ処理などを複数のコアを使用し並列処理することが可能です。
これにより処理速度が向上しますが同時にCPU使用率は上昇するのでトレードオフになります。


## コンパイル時間最小化
詳細は多岐にわたるので以下を参照していただきたいですが、１つ確認できる方法として、cargoにはプログラムのコンパイルを視覚化できる機能があります。
```Rust
cargo build --timings
```
完了すると、HTML ファイルの名前が出力されます。そのファイルを Web ブラウザーで開きます。プログラム内のさまざまなクレート間の依存関係を示すガント チャートが含まれています。これは、クレート グラフにどの程度の並列性があるかを示し、コンパイルをシリアル化する大きなクレートを分割する必要があるかどうかを示します。グラフの読み方の詳細については、[ドキュメント](https://doc.rust-lang.org/nightly/cargo/reference/timings.html)を参照してください。
